<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Chris Higgins">
    <meta name="description" content="Description Here">
    <meta name="keywords" content="security,beer,brewer,metasploit,infosec">

    <base href="https://chigstuff.com/">
    <title>
  Derbycon 4.0 Ctf   Trndocs Elf Binary Reverse Engineering and Debugging · Chiggins Stuff
</title>

    <link rel="canonical" href="https://chigstuff.com/blog/derbycon-4.0-ctf---trndocs-elf-binary-reverse-engineering-and-debugging/">

    <link  rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700">
    <link rel="stylesheet" href="//cdn.rawgit.com/necolas/normalize.css/master/normalize.css">
    <link rel="stylesheet" href="https://chigstuff.com/css/style.min.css">

    <link rel="icon" type="image/png" href="https://chigstuff.com/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://chigstuff.com/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.39" />
  </head>

  <body>
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://chigstuff.com/">
      Chiggins Stuff
    </a>
    
    <ul class="navigation-list float-right">
      
      <li class="navigation-item">
        <a class="navigation-link" href="/blog/">Blog</a>
      </li>
      
      <li class="navigation-item">
        <a class="navigation-link" href="/contributions/">Contributions</a>
      </li>
      
      <li class="navigation-item">
        <a class="navigation-link" href="/files/resume.pdf">Resume</a>
      </li>
      
      <li class="navigation-item">
        <a class="navigation-link" href="/about/">About</a>
      </li>
      
    </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>Derbycon 4.0 Ctf   Trndocs Elf Binary Reverse Engineering and Debugging</h1>
    </header>

    <p>So this past weekend I attended DerbyCon 4.0 in Louisville, Kentucky, and was lucky enough to play the CTF along side the <a href="https://twitter.com/bsjtf">@bsjtf</a> team. We were able to place 16th out of the 77 point scoring teams/individuals, which is pretty damn good I’d say. This write-up will be for a reversing challenge I solved, adding 450 points to the teams total.</p>

<p>One of the first things done was a scan for various services on the network. Since FTP is a common place for CTF flags to hide, went searching for any FTP servers in the environment.</p>

<pre><code>nmap 10.10.146.1/24 -p 21 --open -sV
</code></pre>

<p>One of the FTP servers that stood out was 10.10.146.74 which has anonymous read access and quite an interesting MOTD when logging in.</p>

<pre><code>230-This is a temporary ftp server, while we finish our migration off DOS
230-platforms. For now transaction documents are still availible at
230-/DRIVE_C/TRNDOCS but these are already being generated by the LINUX
230-backend.
230-
230-DOCS for DCs that have already been upgraded are ciphered with
230-OpenSSL, the utility to obtain the shared password from your
230-credentials is TRNDOCS directory.
230-Use the serer xxx.xxx.xxx.xxx to authenticate, you can manually
230-inspect a TRN document with OpenSSL once you obtain the key.
230-
230-openssl des3 -d -salt -in -k
230-
230 User logged in
</code></pre>

<p>Interesting, /DRIVE_C/TRNDOCS/ seems to have a lot of interesting information in it. So I pull everything down and start analyzing the file in there.</p>

<pre><code>[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS]$ ls
ATL  CLE  HBG  PGET_A.OUT  RIC
[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS]$ file PGET_A.OUT
PGET_A.OUT: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, for GNU/Linux 3.2.29, not stripped
[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS]$ cd ATL
[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS/ATL]$ file *
10.TRN: data
11.TRN: data
12.TRN: data
13.TRN: data
14.TRN: data
15.TRN: data
1.TRN:  data
2.TRN:  data
3.TRN:  data
4.TRN:  data
5.TRN:  data
6.TRN:  data
7.TRN:  data
8.TRN:  data
9.TRN:  data
[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS/ATL]$ cd ..
[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS]$ cd CLE
[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS/CLE]$ file *
10.TRN: ASCII text
11.TRN: ASCII text
12.TRN: ASCII text
13.TRN: ASCII text
14.TRN: ASCII text
15.TRN: ASCII text
1.TRN:  ASCII text
2.TRN:  ASCII text
3.TRN:  ASCII text
4.TRN:  ASCII text
5.TRN:  ASCII text
6.TRN:  ASCII text
7.TRN:  ASCII text
8.TRN:  ASCII text
9.TRN:  ASCII text
[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS/CLE]$ cat 1.TRN
invoice: 21815
order: 8925
customer: 30871
scrip: Percocet
days: 14
addr1: James Monroe
addr2: 6596 Euclid
addr3; Zanesville PA 22112
</code></pre>

<p>So it looks like we have a combination of plaintext data, encrypted data, and an ELF binary, which is very interesting. Running strings on the binary doesn’t show anything of super interest. Lets just run it and see what happens.</p>

<pre><code>[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS]$ ./PGET_A.OUT 
Must set options -s (server) -p (password) and -u (username).
[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS]$ ./PGET_A.OUT -s 127.0.0.1 -p password -u user
</code></pre>

<p>The program accepts a server (which I assume it wants to talk to), and a username and password to validate against. Running it with my localhost set as the server just lets it hang, so I’m assuming a socket is being created somewhere. Using strace we’ll be able to see more about this.</p>

<pre><code>[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS]$ strace ./PGET_A.OUT -s 127.0.0.1 -p password -u user
execve(&quot;./PGET_A.OUT&quot;, [&quot;./PGET_A.OUT&quot;, &quot;-s&quot;, &quot;127.0.0.1&quot;, &quot;-p&quot;, &quot;password&quot;, &quot;-u&quot;, &quot;user&quot;], [/* 44 vars */]) = 0
[ Process PID=10312 runs in 32 bit mode. ]
uname({sys=&quot;Linux&quot;, node=&quot;vader&quot;, ...}) = 0
brk(0)                                  = 0x9f55000
brk(0x9f55d40)                          = 0x9f55d40
set_thread_area({entry_number:-1, base_addr:0x9f55840, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0 (entry_number:12)
brk(0x9f76d40)                          = 0x9f76d40
brk(0x9f77000)                          = 0x9f77000
socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP) = 4
sendto(4, &quot;user password&quot;, 13, 0, {sa_family=AF_INET, sin_port=htons(3000), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, 16) = 13
recvfrom(4,
)
</code></pre>

<p>I was right, a socket is trying to make a connection and read back some data. If you notice in sendto, the socket is trying to send data “user password” to 127.0.0.1 on port 3000. I figured that this program was meant to talk to a server on the network, but scanning for an open port 3000 turned out no results. Figured to just keep moving on with this binary and see what else it does.</p>

<p>So I decided to set up a natcat listener on port 3000 and try to receive the data and send data back. One thing that tripped me up with this is that I didn’t realize you needed to tell netcat to listen as a UDP port. Before knowing that, whenever I had my netcat listener running on TCP 3000, the program would not connect to it. After finding out how to specify UDP, I was finally able to send data back and forth.</p>

<pre><code>#### netcat listener ####
[chiggins@vader ~]$ nc -ulvvp 3000
Listening on any address 3000 (hbci)
Received packet from 127.0.0.1:58075 -&gt; 127.0.0.1:3000 (local)
user passwordJUNKDATA

#### program ####
[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS]$ ./PGET_A.OUT -s 127.0.0.1 -p password -u user
bad username or password

#### program with strace ####
[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS]$ strace ./PGET_A.OUT -s 127.0.0.1 -p password -u user
execve(&quot;./PGET_A.OUT&quot;, [&quot;./PGET_A.OUT&quot;, &quot;-s&quot;, &quot;127.0.0.1&quot;, &quot;-p&quot;, &quot;password&quot;, &quot;-u&quot;, &quot;user&quot;], [/* 44 vars */]) = 0
[ Process PID=10537 runs in 32 bit mode. ]
uname({sys=&quot;Linux&quot;, node=&quot;vader&quot;, ...}) = 0
brk(0)                                  = 0x9388000
brk(0x9388d40)                          = 0x9388d40
set_thread_area({entry_number:-1, base_addr:0x9388840, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0 (entry_number:12)
brk(0x93a9d40)                          = 0x93a9d40
brk(0x93aa000)                          = 0x93aa000
socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP) = 4
sendto(4, &quot;user password&quot;, 13, 0, {sa_family=AF_INET, sin_port=htons(3000), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, 16) = 13
recvfrom(4, &quot;JUNKDA&quot;, 6, 0, {sa_family=AF_INET, sin_port=htons(3000), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, [16]) = 6
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7722000
write(1, &quot;bad username or password\n&quot;, 25bad username or password
) = 25
exit_group(0)                           = ?
+++ exited with 0 +++
</code></pre>

<p>So there’s a bit going on here. The netcat listener gets set up to listen on port 3000 with the -u specifing UDP. Then when the program runs, it sends along the specified arguments “user password”. I send back “JUNKDATA” and the program fails saying bad username and password. I also included the strace output, and you’ll notice that the program only reads 6 bytes, “JUNKDA”.</p>

<p>Here is where we start to do some debugging and reversing. I load up the program in gdb, set the required arguments, and take a look at the main method.</p>

<pre><code>[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS]$ gdb -q ./PGET_A.OUT
Reading symbols from ./PGET_A.OUT...done.
gdb&gt;set args -s 127.0.0.1 -u username -p password
gdb&gt;disassemble main
Dump of assembler code for function main:
   0x08048c85 &lt;+0&gt;:	push   ebp
   0x08048c86 &lt;+1&gt;:	mov    ebp,esp
   0x08048c88 &lt;+3&gt;:	push   edi
   0x08048c89 &lt;+4&gt;:	push   esi
   0x08048c8a &lt;+5&gt;:	push   ebx
   0x08048c8b &lt;+6&gt;:	and    esp,0xfffffff0
   0x08048c8e &lt;+9&gt;:	sub    esp,0x50
   0x08048c91 &lt;+12&gt;:	mov    DWORD PTR [esp+0x4c],0x0
   0x08048c99 &lt;+20&gt;:	mov    DWORD PTR [esp+0x48],0x0
   0x08048ca1 &lt;+28&gt;:	mov    DWORD PTR [esp+0x44],0x0
   0x08048ca9 &lt;+36&gt;:	lea    eax,[esp+0x13]
   0x08048cad &lt;+40&gt;:	mov    edx,0x80bac20
   0x08048cb2 &lt;+45&gt;:	mov    ebx,0x25
   0x08048cb7 &lt;+50&gt;:	mov    ecx,eax
   0x08048cb9 &lt;+52&gt;:	and    ecx,0x1
   0x08048cbc &lt;+55&gt;:	test   ecx,ecx
   0x08048cbe &lt;+57&gt;:	je     0x8048cc7 &lt;main+66&gt;
   0x08048cc0 &lt;+59&gt;:	mov    cl,BYTE PTR [edx]
   0x08048cc2 &lt;+61&gt;:	mov    BYTE PTR [eax],cl
   0x08048cc4 &lt;+63&gt;:	inc    eax
   0x08048cc5 &lt;+64&gt;:	inc    edx
   0x08048cc6 &lt;+65&gt;:	dec    ebx
   0x08048cc7 &lt;+66&gt;:	mov    ecx,eax
   0x08048cc9 &lt;+68&gt;:	and    ecx,0x2
   0x08048ccc &lt;+71&gt;:	test   ecx,ecx
   0x08048cce &lt;+73&gt;:	je     0x8048cdf &lt;main+90&gt;
   0x08048cd0 &lt;+75&gt;:	mov    cx,WORD PTR [edx]
   0x08048cd3 &lt;+78&gt;:	mov    WORD PTR [eax],cx
   0x08048cd6 &lt;+81&gt;:	add    eax,0x2
   0x08048cd9 &lt;+84&gt;:	add    edx,0x2
   0x08048cdc &lt;+87&gt;:	sub    ebx,0x2
   0x08048cdf &lt;+90&gt;:	mov    ecx,ebx
   0x08048ce1 &lt;+92&gt;:	shr    ecx,0x2
   0x08048ce4 &lt;+95&gt;:	mov    edi,eax
   0x08048ce6 &lt;+97&gt;:	mov    esi,edx
   0x08048ce8 &lt;+99&gt;:	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
   0x08048cea &lt;+101&gt;:	mov    edx,esi
   0x08048cec &lt;+103&gt;:	mov    eax,edi
   0x08048cee &lt;+105&gt;:	mov    ecx,0x0
   0x08048cf3 &lt;+110&gt;:	mov    esi,ebx
   0x08048cf5 &lt;+112&gt;:	and    esi,0x2
   0x08048cf8 &lt;+115&gt;:	test   esi,esi
   0x08048cfa &lt;+117&gt;:	je     0x8048d07 &lt;main+130&gt;
   0x08048cfc &lt;+119&gt;:	mov    si,WORD PTR [edx+ecx*1]
   0x08048d00 &lt;+123&gt;:	mov    WORD PTR [eax+ecx*1],si
   0x08048d04 &lt;+127&gt;:	add    ecx,0x2
   0x08048d07 &lt;+130&gt;:	and    ebx,0x1
   0x08048d0a &lt;+133&gt;:	test   ebx,ebx
   0x08048d0c &lt;+135&gt;:	je     0x8048d14 &lt;main+143&gt;
   0x08048d0e &lt;+137&gt;:	mov    dl,BYTE PTR [edx+ecx*1]
   0x08048d11 &lt;+140&gt;:	mov    BYTE PTR [eax+ecx*1],dl
   0x08048d14 &lt;+143&gt;:	mov    DWORD PTR ds:0x80e4a18,0x0
   0x08048d1e &lt;+153&gt;:	jmp    0x8048d75 &lt;main+240&gt;
   0x08048d20 &lt;+155&gt;:	cmp    DWORD PTR [esp+0x3c],0x75
   0x08048d25 &lt;+160&gt;:	jne    0x8048d32 &lt;main+173&gt;
   0x08048d27 &lt;+162&gt;:	mov    eax,ds:0x80e6218
   0x08048d2c &lt;+167&gt;:	mov    DWORD PTR [esp+0x4c],eax
   0x08048d30 &lt;+171&gt;:	jmp    0x8048d75 &lt;main+240&gt;
   0x08048d32 &lt;+173&gt;:	cmp    DWORD PTR [esp+0x3c],0x70
   0x08048d37 &lt;+178&gt;:	jne    0x8048d44 &lt;main+191&gt;
   0x08048d39 &lt;+180&gt;:	mov    eax,ds:0x80e6218
   0x08048d3e &lt;+185&gt;:	mov    DWORD PTR [esp+0x48],eax
   0x08048d42 &lt;+189&gt;:	jmp    0x8048d75 &lt;main+240&gt;
   0x08048d44 &lt;+191&gt;:	cmp    DWORD PTR [esp+0x3c],0x73
   0x08048d49 &lt;+196&gt;:	jne    0x8048d56 &lt;main+209&gt;
   0x08048d4b &lt;+198&gt;:	mov    eax,ds:0x80e6218
   0x08048d50 &lt;+203&gt;:	mov    DWORD PTR [esp+0x44],eax
   0x08048d54 &lt;+207&gt;:	jmp    0x8048d75 &lt;main+240&gt;
   0x08048d56 &lt;+209&gt;:	mov    edx,DWORD PTR ds:0x80e4a14
   0x08048d5c &lt;+215&gt;:	mov    eax,ds:0x80e453c
   0x08048d61 &lt;+220&gt;:	mov    DWORD PTR [esp+0x8],edx
   0x08048d65 &lt;+224&gt;:	mov    DWORD PTR [esp+0x4],0x80bab4e
   0x08048d6d &lt;+232&gt;:	mov    DWORD PTR [esp],eax
   0x08048d70 &lt;+235&gt;:	call   0x80498a0 &lt;fprintf&gt;
   0x08048d75 &lt;+240&gt;:	mov    DWORD PTR [esp+0x8],0x80bab62
   0x08048d7d &lt;+248&gt;:	mov    eax,DWORD PTR [ebp+0xc]
   0x08048d80 &lt;+251&gt;:	mov    DWORD PTR [esp+0x4],eax
   0x08048d84 &lt;+255&gt;:	mov    eax,DWORD PTR [ebp+0x8]
   0x08048d87 &lt;+258&gt;:	mov    DWORD PTR [esp],eax
   0x08048d8a &lt;+261&gt;:	call   0x8055b10 &lt;getopt&gt;
   0x08048d8f &lt;+266&gt;:	mov    DWORD PTR [esp+0x3c],eax
   0x08048d93 &lt;+270&gt;:	cmp    DWORD PTR [esp+0x3c],0xffffffff
   0x08048d98 &lt;+275&gt;:	jne    0x8048d20 &lt;main+155&gt;
   0x08048d9a &lt;+277&gt;:	cmp    DWORD PTR [esp+0x4c],0x0
   0x08048d9f &lt;+282&gt;:	je     0x8048daf &lt;main+298&gt;
   0x08048da1 &lt;+284&gt;:	cmp    DWORD PTR [esp+0x48],0x0
   0x08048da6 &lt;+289&gt;:	je     0x8048daf &lt;main+298&gt;
   0x08048da8 &lt;+291&gt;:	cmp    DWORD PTR [esp+0x44],0x0
   0x08048dad &lt;+296&gt;:	jne    0x8048dde &lt;main+345&gt;
   0x08048daf &lt;+298&gt;:	mov    eax,ds:0x80e453c
   0x08048db4 &lt;+303&gt;:	mov    DWORD PTR [esp+0xc],eax
   0x08048db8 &lt;+307&gt;:	mov    DWORD PTR [esp+0x8],0x3e
   0x08048dc0 &lt;+315&gt;:	mov    DWORD PTR [esp+0x4],0x1
   0x08048dc8 &lt;+323&gt;:	mov    DWORD PTR [esp],0x80bab6c
   0x08048dcf &lt;+330&gt;:	call   0x8049900 &lt;fwrite&gt;
   0x08048dd4 &lt;+335&gt;:	mov    eax,0x1
   0x08048dd9 &lt;+340&gt;:	jmp    0x8048eed &lt;main+616&gt;
   0x08048dde &lt;+345&gt;:	mov    DWORD PTR [esp+0x8],0x11
   0x08048de6 &lt;+353&gt;:	mov    DWORD PTR [esp+0x4],0x2
   0x08048dee &lt;+361&gt;:	mov    DWORD PTR [esp],0x2
   0x08048df5 &lt;+368&gt;:	call   0x8057100 &lt;socket&gt;
   0x08048dfa &lt;+373&gt;:	mov    DWORD PTR [esp+0x38],eax
   0x08048dfe &lt;+377&gt;:	cmp    DWORD PTR [esp+0x38],0x0
   0x08048e03 &lt;+382&gt;:	jns    0x8048e34 &lt;main+431&gt;
   0x08048e05 &lt;+384&gt;:	mov    eax,ds:0x80e453c
   0x08048e0a &lt;+389&gt;:	mov    DWORD PTR [esp+0xc],eax
   0x08048e0e &lt;+393&gt;:	mov    DWORD PTR [esp+0x8],0x16
   0x08048e16 &lt;+401&gt;:	mov    DWORD PTR [esp+0x4],0x1
   0x08048e1e &lt;+409&gt;:	mov    DWORD PTR [esp],0x80babab
   0x08048e25 &lt;+416&gt;:	call   0x8049900 &lt;fwrite&gt;
   0x08048e2a &lt;+421&gt;:	mov    eax,0x1
   0x08048e2f &lt;+426&gt;:	jmp    0x8048eed &lt;main+616&gt;
   0x08048e34 &lt;+431&gt;:	mov    eax,DWORD PTR [esp+0x38]
   0x08048e38 &lt;+435&gt;:	mov    DWORD PTR [esp+0xc],eax
   0x08048e3c &lt;+439&gt;:	mov    eax,DWORD PTR [esp+0x44]
   0x08048e40 &lt;+443&gt;:	mov    DWORD PTR [esp+0x8],eax
   0x08048e44 &lt;+447&gt;:	mov    eax,DWORD PTR [esp+0x48]
   0x08048e48 &lt;+451&gt;:	mov    DWORD PTR [esp+0x4],eax
   0x08048e4c &lt;+455&gt;:	mov    eax,DWORD PTR [esp+0x4c]
   0x08048e50 &lt;+459&gt;:	mov    DWORD PTR [esp],eax
   0x08048e53 &lt;+462&gt;:	call   0x8048aec &lt;sendAuth&gt;
   0x08048e58 &lt;+467&gt;:	test   eax,eax
   0x08048e5a &lt;+469&gt;:	je     0x8048ec3 &lt;main+574&gt;
   0x08048e5c &lt;+471&gt;:	mov    eax,DWORD PTR [esp+0x38]
   0x08048e60 &lt;+475&gt;:	mov    DWORD PTR [esp],eax
   0x08048e63 &lt;+478&gt;:	call   0x8048bde &lt;recvAuth&gt;
   0x08048e68 &lt;+483&gt;:	test   eax,eax
   0x08048e6a &lt;+485&gt;:	je     0x8048eb5 &lt;main+560&gt;
   0x08048e6c &lt;+487&gt;:	mov    DWORD PTR [esp],0x80babc2
   0x08048e73 &lt;+494&gt;:	call   0x8049a50 &lt;puts&gt;
   0x08048e78 &lt;+499&gt;:	mov    DWORD PTR [esp+0x40],0x0
   0x08048e80 &lt;+507&gt;:	jmp    0x8048ea0 &lt;main+539&gt;
   0x08048e82 &lt;+509&gt;:	lea    edx,[esp+0x13]
   0x08048e86 &lt;+513&gt;:	mov    eax,DWORD PTR [esp+0x40]
   0x08048e8a &lt;+517&gt;:	add    eax,edx
   0x08048e8c &lt;+519&gt;:	mov    al,BYTE PTR [eax]
   0x08048e8e &lt;+521&gt;:	xor    eax,0x17
   0x08048e91 &lt;+524&gt;:	movsx  eax,al
   0x08048e94 &lt;+527&gt;:	mov    DWORD PTR [esp],eax
   0x08048e97 &lt;+530&gt;:	call   0x8049c80 &lt;putchar&gt;
   0x08048e9c &lt;+535&gt;:	inc    DWORD PTR [esp+0x40]
   0x08048ea0 &lt;+539&gt;:	cmp    DWORD PTR [esp+0x40],0x24
   0x08048ea5 &lt;+544&gt;:	jle    0x8048e82 &lt;main+509&gt;
   0x08048ea7 &lt;+546&gt;:	mov    DWORD PTR [esp],0xa
   0x08048eae &lt;+553&gt;:	call   0x8049c80 &lt;putchar&gt;
   0x08048eb3 &lt;+558&gt;:	jmp    0x8048ee8 &lt;main+611&gt;
   0x08048eb5 &lt;+560&gt;:	mov    DWORD PTR [esp],0x80babca
   0x08048ebc &lt;+567&gt;:	call   0x8049a50 &lt;puts&gt;
   0x08048ec1 &lt;+572&gt;:	jmp    0x8048ee8 &lt;main+611&gt;
   0x08048ec3 &lt;+574&gt;:	mov    eax,ds:0x80e453c
   0x08048ec8 &lt;+579&gt;:	mov    DWORD PTR [esp+0xc],eax
   0x08048ecc &lt;+583&gt;:	mov    DWORD PTR [esp+0x8],0x1e
   0x08048ed4 &lt;+591&gt;:	mov    DWORD PTR [esp+0x4],0x1
   0x08048edc &lt;+599&gt;:	mov    DWORD PTR [esp],0x80babe4
   0x08048ee3 &lt;+606&gt;:	call   0x8049900 &lt;fwrite&gt;
   0x08048ee8 &lt;+611&gt;:	mov    eax,0x0
   0x08048eed &lt;+616&gt;:	lea    esp,[ebp-0xc]
   0x08048ef0 &lt;+619&gt;:	pop    ebx
   0x08048ef1 &lt;+620&gt;:	pop    esi
   0x08048ef2 &lt;+621&gt;:	pop    edi
   0x08048ef3 &lt;+622&gt;:	pop    ebp
   0x08048ef4 &lt;+623&gt;:	ret
End of assembler dump.
</code></pre>

<p>The disassembly for main is pretty crazy, but if you just walk through it, it’s not too bad. It does some argument checking, creates a socket (0x08048df5 &lt;+368&gt;), sends the authentication data (0x08048e53 &lt;+462&gt;), receives the authentication response (0x08048e63 &lt;+478&gt;), and some more nonsense towards the end.</p>

<p>Something interesting that I noticed is that right after we receive the authentication data, a test is done on eax against eax (0x08048e68 &lt;+483&gt;). In assembly, the return value of a function is stored in eax, so this test is looking to verify the return of the recvAuth method. I think it is safe to assume that here is where the program will decide to give us either the “bad username or password” text, or continue on to do something more.</p>

<p>Before I continued, I had to look up what test actually did. From <a href="https://stackoverflow.com/questions/13064809/the-point-of-test-eax-eax">this question on StackOverflow</a>, “TEST sets the Zero Flag if the the result of the AND operation is zero. If two operands are equal, their bitwise AND is zero iff both are zero. It also sets the Sign Flag if the top bit is set in the result, and the Parity Flag if the number of set bits is even.” What this means is that in our program, if eax is set to 0x0, then the program will jump to 0x8048eb5 , which is towards the end of the program. If we put a breakpoint at this location and look at the registers and disassembly, we can see this happen.</p>

<pre><code>gdb&gt;break *0x08048e68
Breakpoint 1 at 0x8048e68
gdb&gt;run
Starting program: /home/chiggins/DerbyCon4.0/74/DRIVE_C/TRNDOCS/PGET_A.OUT -s 127.0.0.1 -u username -p password
Got object file from memory but can't read symbols: File truncated.

Breakpoint 1, 0x08048e68 in main ()
gdb&gt;info registers
eax            0x0	0x0
ecx            0xffffd5e8	0xffffd5e8
edx            0xffffd54a	0xffffd54a
ebx            0x0	0x0
esp            0xffffd610	0xffffd610
ebp            0xffffd678	0xffffd678
esi            0x0	0x0
edi            0xffffd648	0xffffd648
eip            0x8048e68	0x8048e68 &lt;main+483&gt;
eflags         0x287	[ CF PF SF IF ]
cs             0x23	0x23
ss             0x2b	0x2b
ds             0x2b	0x2b
es             0x2b	0x2b
fs             0x0	0x0
gs             0x63	0x63
gdb&gt;disassemble main
Dump of assembler code for function main:
[... snip ...]
   0x08048e53 &lt;+462&gt;:	call   0x8048aec &lt;sendAuth&gt;
   0x08048e58 &lt;+467&gt;:	test   eax,eax
   0x08048e5a &lt;+469&gt;:	je     0x8048ec3 &lt;main+574&gt;
   0x08048e5c &lt;+471&gt;:	mov    eax,DWORD PTR [esp+0x38]
   0x08048e60 &lt;+475&gt;:	mov    DWORD PTR [esp],eax
   0x08048e63 &lt;+478&gt;:	call   0x8048bde &lt;recvAuth&gt;
=&gt; 0x08048e68 &lt;+483&gt;:	test   eax,eax
   0x08048e6a &lt;+485&gt;:	je     0x8048eb5 &lt;main+560&gt;
   0x08048e6c &lt;+487&gt;:	mov    DWORD PTR [esp],0x80babc2
   0x08048e73 &lt;+494&gt;:	call   0x8049a50 &lt;puts&gt;
   0x08048e78 &lt;+499&gt;:	mov    DWORD PTR [esp+0x40],0x0
   0x08048e80 &lt;+507&gt;:	jmp    0x8048ea0 &lt;main+539&gt;
   0x08048e82 &lt;+509&gt;:	lea    edx,[esp+0x13]
[... snip ...]
End of assembler dump.
gdb&gt;continue
Continuing.
bad username or password
[Inferior 1 (process 11299) exited normally]
</code></pre>

<p>So after recvAuth eax was set to 0x0 which caused the result from test to jump to the end of the program and show the bad password message. What happens if we set eax to 0x1, maybe it will bypass the jump and continue onto something more interesting.</p>

<pre><code>gdb&gt;run
Starting program: /home/chiggins/DerbyCon4.0/74/DRIVE_C/TRNDOCS/PGET_A.OUT -s 127.0.0.1 -u username -p password
Got object file from memory but can't read symbols: File truncated.

Breakpoint 1, 0x08048e68 in main ()
gdb&gt;disassemble main
Dump of assembler code for function main:
[... snip ...]
   0x08048e53 &lt;+462&gt;:   call   0x8048aec &lt;sendAuth&gt;
   0x08048e58 &lt;+467&gt;:   test   eax,eax
   0x08048e5a &lt;+469&gt;:   je     0x8048ec3 &lt;main+574&gt;
   0x08048e5c &lt;+471&gt;:   mov    eax,DWORD PTR [esp+0x38]
   0x08048e60 &lt;+475&gt;:   mov    DWORD PTR [esp],eax
   0x08048e63 &lt;+478&gt;:   call   0x8048bde &lt;recvAuth&gt;
=&gt; 0x08048e68 &lt;+483&gt;:   test   eax,eax
   0x08048e6a &lt;+485&gt;:   je     0x8048eb5 &lt;main+560&gt;
   0x08048e6c &lt;+487&gt;:   mov    DWORD PTR [esp],0x80babc2
   0x08048e73 &lt;+494&gt;:   call   0x8049a50 &lt;puts&gt;
   0x08048e78 &lt;+499&gt;:   mov    DWORD PTR [esp+0x40],0x0
   0x08048e80 &lt;+507&gt;:   jmp    0x8048ea0 &lt;main+539&gt;
   0x08048e82 &lt;+509&gt;:   lea    edx,[esp+0x13]
[... snip ...]
End of assembler dump.
gdb&gt;info registers 
eax            0x0	0x0
ecx            0xffffd5e8	0xffffd5e8
edx            0xffffd54a	0xffffd54a
ebx            0x0	0x0
esp            0xffffd610	0xffffd610
ebp            0xffffd678	0xffffd678
esi            0x0	0x0
edi            0xffffd648	0xffffd648
eip            0x8048e68	0x8048e68 &lt;main+483&gt;
eflags         0x287	[ CF PF SF IF ]
cs             0x23	0x23
ss             0x2b	0x2b
ds             0x2b	0x2b
es             0x2b	0x2b
fs             0x0	0x0
gs             0x63	0x63
gdb&gt;set $eax = 0x1
gdb&gt;info registers
eax            0x1	0x1
ecx            0xffffd5e8	0xffffd5e8
edx            0xffffd54a	0xffffd54a
ebx            0x0	0x0
esp            0xffffd610	0xffffd610
ebp            0xffffd678	0xffffd678
esi            0x0	0x0
edi            0xffffd648	0xffffd648
eip            0x8048e68	0x8048e68 &lt;main+483&gt;
eflags         0x287	[ CF PF SF IF ]
cs             0x23	0x23
ss             0x2b	0x2b
ds             0x2b	0x2b
es             0x2b	0x2b
fs             0x0	0x0
gs             0x63	0x63
gdb&gt;continue
Continuing.
Success
The secret key is EverybodyDoTheLimit
[Inferior 1 (process 11416) exited normally]
</code></pre>

<p>Woah! Would you look at that, got something juicy. I tried to submit “EverybodyDoTheLimit” as a flag, but it ended up not being valid. But if you recall back to the FTP MOTD at the beginning of the post, we can now expect the TRN documents via openssl with the newly acquired secret key. After running through the various encrypted files, I finally ran into one with a flag in it.</p>

<pre><code>[chiggins@vader ~/DerbyCon4.0/74/DRIVE_C/TRNDOCS/ATL]$ openssl des3 -d -salt -in 2.TRN -k EverybodyDoTheLimit
invoice: 19755
order: 11389
customer: 24956
scrip: flag
days: 90
addr1: CountingSheep75
addr2: 8982 Elm
addr3; Henderson LA 13131
</code></pre>

<p>Submitted “CountingSheep75” to the scoring engine, and received 450 points. Woo!</p>

<p>Since I’ve really been getting into reverse engineering and debugging lately, this was a really fun challenge for me. Thanks to the DerbyCon CTF crew for creating this one!</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    © 2018 · Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
  </section>
</footer>

    </main>

    

  </body>

</html>
